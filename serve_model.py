import os
import requests
import json
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow import keras
from tensorflow.python import training
from tensorflow.python.framework.ops import disable_eager_execution
disable_eager_execution()
np.random.seed(42)
tf.random.set_seed(42)

project_dir = './'
data_path = os.path.join(project_dir, 'data')

# function for reading data
def read_data(filename, date_cols=None, file_path=data_path):
    csv_path = os.path.join(file_path, filename)
    return pd.read_csv(csv_path, parse_dates=date_cols)

# function for saving data as csv file
def save_dataframe(df, filename, file_path=data_path):
    path = os.path.join(file_path, filename)
    df.to_csv(path, index=False)

train = read_data("TRAIN.CSV", date_cols=["Date"])
test = read_data("TEST_FINAL.csv", date_cols=["Date"])
submission = read_data("SAMPLE.csv")

from prepare import prepare_data
X_train, y_train, X_test, full_pipe = prepare_data(train, test)

# select numerical and categorical columns
num_cols = X_train.select_dtypes(exclude=["object", "category"]).columns.tolist()
cat_cols = X_train.select_dtypes(include=["object", "category"]).columns.tolist()

X_train = full_pipe.fit_transform(X_train)
X_test = full_pipe.transform(X_test)

# Get the list of categories generated by the one-hot-encoder
ohe_categories = full_pipe.named_transformers_.cat.named_steps.onehotencoder.categories_

# Create nice names for our one hot encoded features
new_ohe_features = [
    f"{col}__{val}" for col, vals in zip(cat_cols, ohe_categories) for val in vals
]

# Create a new list with all names of features
all_features = num_cols + new_ohe_features

# Create pandas dataframe
X_train_tr = pd.DataFrame(X_train, columns=all_features)
X_test_tr = pd.DataFrame(X_test, columns=all_features)

y_train_tr = y_train.copy()
n = len(X_train_tr)
X_train = X_train_tr[:int(n*0.7)]
y_train = y_train_tr[:int(n*0.7)]

X_valid = X_train_tr[int(n*0.7):]
y_valid = y_train_tr[int(n*0.7):]


# create the neural network
keras.backend.clear_session()

model = keras.models.Sequential([
        keras.layers.Dense(64, activation="relu", input_shape=X_train.shape[1:]),
        keras.layers.Dropout(0.3),
        keras.layers.Dense(64, activation="relu"),
        keras.layers.Dropout(0.3),
        keras.layers.Dense(1)
])

# # compile the model
model.compile(optimizer="rmsprop", 
              loss= "mean_squared_logarithmic_error", 
              metrics=['mean_squared_logarithmic_error'])

#early stopping callback
early_stopping_cb = keras.callbacks.EarlyStopping(patience=10,
                                                 restore_best_weights=True)

# # train the model
history = model.fit(X_train, y_train,
                    validation_data=(X_valid, y_valid),
                    epochs=3, callbacks=[early_stopping_cb])

y_pred = model.predict(X_test[:5])

model.save("saved_model/1/")
















